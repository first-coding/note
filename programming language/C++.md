- **输入与输出**：cin标准输入，cout标准输出
	- 头文件iostream为标准输入/输出库。
	- 运算符：
		- **输出运算符**：ostream对象<< 需要打印的值
			- **endl**：是一个操纵符，结束当前行，将缓冲区内容刷新到设备中。
		- **输入运算符**：istream对象>>运算对象
- **基础**：
	- **变量和基本类型**：
		- **基本内置类型**：
			- **算术类型**：
				- **整型**：包括字符和布尔类型在内，**数字表示标准规定的最小值**，但是不同机器存在差异。
					- 布尔：**bool**
					- 字符：**char（8位）**
					- 宽字符：**wchar_t（16位）**
					- Unicode字符：
						- **char16_t：16位**
						- **char32_t：32位**
					- 短整型：**short （16位）**
					- 整型：**int （16位）**
					- 长整型：**long（32位）**
					- 长整型：**long long （64位）**
				- **浮点型**：
					- 单精度浮点数：**float （6位有效数字）**
					- 双精度浮点数：**double （10位有效数字）**
					- 扩展精度浮点数：**long double（10位有效数字）**
				- **默认都是带符号的，使用关键字unsigned表示无符号的。无符号只能表示>0的数字。**
			- **空类型**：**void**
		- **类型转换**：
			- 如果转换的类型数值大小不够大的时候，可能会出错，导致程序崩溃，或者生成垃圾数据。
		- **字面值常量**：就是一个值，分为
			- **整型和浮点型**，例如：3.14159，3.14159E0
			- **字符和字符串字面值**，例如：‘a’，“Hello world！”
			- **转义序列**：'\n','\v','\a'.......
			- **布尔字面值和指针字面值**：nullptr是指针字面值，false这种是布尔字面值。
		- **变量**：
			- 定义基本形式：**类型说明符**+**一个或多个变量名组成的列表**+**；**。eg：`int a；`
			- 对象是什么：指的是**一块能存储数据并具有某种类型的内存空间。**
			- **变量初始化**：**当对象在创建时获得一个特定的值**。就说对象被**初始化**。
			- **初始化和赋值**：
				- 初始化：是创建变量时赋予一个初始值。
				- 赋值：把对象当前值擦除，用一个新值替代。
			- **列表初始化**：
				- 可以用{}进行列表初始化.
					- `int sold = {0};`
					- `int sold{0};`
					- `int sold(0);`
			- **默认初始化**：定义变量没有指定初值，则变量被默认初始化。默认值是多少由变量类型决定。
			- **声明和定义关系**：
				- 声明：名字为程序所知，**一个文件如果想使用另一个文件定义的变量则必须需要在文件中进行声明**。
				- 定义：**负责创建与名字关联的实体。**
				- 声明与定义：
					- 声明（extern关键字）：`extern int i`;
					- 定义：`int i / int j=1;`
					- 变量只能被定义一次，但是可以被多次声明。
			- **标识符**：由字母，数字和下划线组成，必须以字母或者下划线开头。没有长度限制，但有大小写区别。
			- **复合类型**：
				- **指针**：是“指向”另外一种类型的复合类型。指针也实现了对其他对象的间接访问，**指针是一个对象，允许赋值和拷贝。** **指针可以无须一定要进行初始化，没有被初始化也会有不确定的值。**
					- 定义指针类型为 `*d` ,d为变量名，每个变量前面必须有符号 `*` 。
					- 获取对象的地址，需要用**取地址符(&)**。
						- `int ival=42;int *p = &ival;`
					- 指针的值（即地址），4中状态之一
						- **指向一个对象。**
						- **指向紧邻对象所占空间的下一个位置。**
						- **空指针，意味着指针没有指向任何对象。**
							- `int *p=nullptr` # 这是c++11新标准
							- `int *p2=0`
							- `int *p3=NULL` # 需要加入头文件 cstdlib，它的值是0。
						- **无效指针，也就是上述情况之外的其他值。**
					- void* 指针：
						- 是一种特殊的指针类型，可用于存放任意对象的地址。
					- 利用指针访问对象
						- `int ival=42; int *p = &ival; cout << *p;`
						- 解引用(操作符*)访问该对象；`*p` 得到该指针p所指的对象，输出42。
				- **引用**：**为对象起另外一个名字**，引用类型引用另外一种类型，**通过将声明符写成&d的形式来定义引用类型**。d是声明的变量名。就是把引用和它的初始值绑定在一起。（**引用必须被初始化**）。
					- PS：
						- **不能定义引用的引用。**
						- **引用必须要是同一种类型说明符，对int对象的引用也要是int类型的引用。**
					- eg:
						- `int i=1024; ` # 这是定义了一个变量。
						- `int &r = i;` # 这是引用，与i绑定在一起。
				- **对指针的引用**：`int *p; int *&r=p;(对指针的引用)`
			- **const 限定符**：**const关键字声明的变量值不能被改变。**
				- 当多个文件使用的时候，默认只在文件内有效，想解决这个问题用
					- `extern const int bufSize;`
					- 对于const变量不管是声明还是定义都添加extern关键字。
					- ps：想要知道什么是常量建议从右往左读。
			- **constexpr关键字**：**指值不会改变并且在编译过程就能得到计算结果的表达式。**
			- **const和constexpr**：
				- const：
					- 用于声明不可变的变量。
					- 防止修改函数参数或返回值。
					- 声明常量，指针等。
					- 运行时常量，值在运行时确定。
					- 不要求在编译时计算值。
					- eg:
						- `const int x = 5; // 不可变的变量`
						- `void foo(const int y); // 防止修改的函数参数`
				- constexpr:
					- 用于声明在编译时计算出值的常量表达式。
					- 可用于函数、变量。
					- 编译时常量，值在编译时确定。
					- 要求在编译时计算值。
					- eg:
						- `constexpr int x = 5; // 编译时常量`
						- `constexpr int square(int x) { return x * x; } // 编译时计算的函数`
			- **类型别名**：
				- **typedef**：`typedef double wages;`
				- **using**：`using SI = Sales_Item;`
				- **这两种方式都是给类型起其他名字。**
			- **auto类型说明符**：
				- **auto**：让编译器分析表达式所属的类型。
					- `auto i=0;` 自动推算i的类型。
			- **decltype类型指示符**：
				- decltype：从表达式的类型推断出要定义的变量类型。
					- `decltype (f()) sum = x;` sum的类型就是函数f的返回类型。
			- **预处理器**：
				- `#define` 指令把一个名字设定为预处理变量。
				- `#ifdef` 当且仅当变量已定义时为真。
				- `#ifndef` 当且仅当变量未定义为真。
					- 一旦检查结果为真，则执行后续操作直至遇到`#endif`为止。
	- **字符串、向量和数组**：
		- **命令空间的using声明**：
			- `using namespace::name` 这样可以在namespace中使用name这个对象。
			- ps：当使用`using namespace std` 就不需要再每个对象都导入了。std命令空间中所有函数和对象都可以不需要`std::name` 这样使用了。可以直接`name` 这个样子了。
		- **标准库类型string**：[[#^7cfc1f]]
			- `#include<string>  using std::string`
			- **定义string对象**
				- `string s1;`
				- `string s2 = s1`
				- `string s3 = "hiya";`
				- `string s4(10,'c');` s4的内容是10个c
			- **初始化string对象**：
				- **拷贝初始化**：用等号=初始化一个变量。
					- `string s5="hiya";` 
					- `string s8= string(10,'c')`
				- **直接初始化**：不用等号的话就是直接初始化。
					- `string s6("hiya");`
					- `string s7(10,'c');`
			- **string对象上的操作**：
				- `os<<s`  将s写到输出流os当中，返回os
				- `is>>s`  从is中读取字符串赋给s，字符串以空白分隔，返回is
				- `getline(is,s)` 从is中读取一行赋给s，返回is
				- `s.empty()` s为空返回true，否则返回false
				- `s.size()` 返回s中字符的个数
				- `s[n]` 返回s中第n个字符的引用，从0开始计起
				- `s1+s2` 返回s1和s2连接后的结果
				- `s1=s2` 用s2的副本代替s1中原来的字符
				- `s1==s2 / s1!=s2` 如果s1和s2中所含的字符一样，则它们相等；string对象的相等性判断对字母的大小敏感。
				- `<,<=,>,>=` 利用字符在字典中的顺序进行比较，且对字母的大小写敏感。
			- **empty与size**：
				- empty函数根据string对象是否为空返回一个对应的布尔值。
				- size函数返回string对象的长度。返回的类型为string::size_type类型
			- `string s1; cin >> s1; cout << s1 << endl;` 读取string对象，遇到空白就停止
			- `string s1,s2; cin >> s1 >> s2; cout << s1 << s2 << endl；` 多个变量输入与输出
			- `string word; while(cin >> word){cout << word << endl;}` 读取未知数量的string对象
			- `string line; while(getline(cin,line)){cout << line << endl;}` getline读取一整行
			- **处理string对象中的字符**
				- `#include<cctype>` 
					- `isalnum(c)` 当c是字母或数字时为真
					- `isalpha(c)` 当c是字母时为真
					- `iscntrl(c)` 当c是控制字符时为真
					- `isdigit(c)` 当c是数字时为真
					- `isgraph(c)` 当c不是空格但可打印时为真
					- `islower(c)` 当c是小写字母时为真
					- `isprint(c)` 当c是可打印字符时为真(即c是空格或c具有可视形式)
					- `ispunct(c)` 当c是标点符号时为真（即c不是控制字符，数字，字母，可打印空白中的一种）
					- `isspace(c)` 当c是空白时为真（即c是空格，横向制表符，纵向制表符，回车符，换行符，进纸符中的一种）
					- `isupper(c)` 当c是大写字母时为真
					- `isxdigit(c)` 当c是十六进制数字时为真
					- `tolower(c)` 如果c是大写字母，输入对应的小写字母，否则原样输出c
					- `toupper(c)` 如果c是小写字母，输出对应的大写字母，否则原样输出c
				- **范围的for语句**：
					- for(declaration: expression)
						- declaration：定义一个变量，用于访问序列中的基础元素。
						- expression：是一个对象，用于表示一个序列。
				- **下标运算符 ( `[]` )**:
					- `[]` 接收的输入参数为string::size_type类型的值。
		- **标准库类型vector**：[[#^7cfc1f]]
			- **vector**表示对象的集合，其中所有对象的类型都相同，也叫容器
				- `#include<vector> using std::vector` 
				- `vector<int> ivec;` ivec保存int类型的对象
				- `vector<Sales_item> Sales_vec;` 保存Sales_item类型的对象
				- `vector<vector<string>> file` 该向量的元素是vector对象
			- **定义和初始化vector对象**：
				- `vector<T> v1` v1是一个空vector，元素类型是T，执行默认初始化
				- `vector<T> v2(v1)` v2中包含有v1所有元素的副本
				- `vector<T> v2=v1` 等价于v2(v1)，v2中包含有v1所有元素的副本
				- `vector<T> v3(n,val)` v3包含n个重复的元素，每个元素的值都是val
				- `vector<T> v4(n)` v4包含n个重复地执行了值初始化的对象
				- `vector<T> v5{a,b,c...}` v5包含了初始值个数的元素，每个元素被赋予相应的初始值
				- `vector<T> v5={a,b,c,...}` 等价于v5{a,b,c,...}
			- **向vector对象中添加元素**：
				- **push_back**：在vector尾端添加新的对象。
					- `vector<string> text; test.push_back(new_word);`
					- `text.empty()` 查看text是否含有元素
					- `text.size()` 返回text中元素的个数
					- `text[n]` 返回text中第n个位置上元素的引用，可用这个返回元素，**但是不可以用这种方式添加元素**
					- `v=text` 将text中的元素拷贝替换v的元素
					- `v={a,b,c...}` 用列表中元素的拷贝替换v中的元素
					- `v1==v2 / v1!=v2 / <,<=,>,>=` 比较
		- **迭代器（iterator）**：**所有标准库容器都可以使用迭代器，但是string也可以使用迭代器**。
			- 使用迭代器：`auto b=v.begin(),e=v.end()` begin是v第一个元素，end是容器v尾元素的下一个位置。
			- **迭代器运算符**：
				- `*iter`：返回迭代器iter所指元素的引用
				- `iter->mem`：解引用iter并获取该元素的名为mem的成员，等价于`(*iter).mem` 
				- `++iter`：令iter指示容器中的下一个元素
				- `--iter`：令iter指示容器中的上一个元素
				- `iter1== / ！= iter2` 都是判断这两个容器是否相等
		- **数组**：
			- **定义和初始化内置数组**：
				- `int arr[10];` 含有10个整数的数组
				- `constexpr unsigned sz=42;int *parr[sz];` 含有42个整型指针的数组
			- **显式初始化数组元素**：
				- `const unsigned sz=3; int ia1[sz]={0,1,2}; int a2[]={0,1,2};`
				- **不允许使用一个数组初始化另一个数组。**
			- 指针和数组与c一样。
			- **C风格字符串**：
				- `include<cstring>` cstring是C语言头文件string.h的C++版本
					- `strlen(p)` 返回p的长度，空字符不计算在内
					- `strcmp(p1,p2)` 比较p1和p2.
					- `strcat(p1,p2)` 将p2附加到p1之后，返回p1
					- `strcpy(p1,p2)` 将p2拷贝给p1，返回p1
			- **大部分操作和C语言类似**
	- **表达式**：
		- **一元运算符**：
			- **递增和递减运算符**：
				- **递增（++）**：对象加一
				- **递减（--）**：对象减一
			- **正负号运算符**：
				- **正号（+）**
				- **负号（-）**
			- **逻辑非运算符**：
				- **非（！）**
			- **按位取反运算符**:
				- **按位取反（~）**
			- **地址和解引用运算符**：
				- **取地址（&）**
				- **解引用（ * ）**
		- **二元运算符**：
			- **算术运算符**：
				- **加法（+）**
				- **减法（-）**
				- **乘法（ * ）**
				- **除法（/）**
				- **取模（%）**
			- **关系运算符**：
				- **等于（ == ）**
				- **不等于（!=）**
				- **大于（>）**
				- **小于（<）**
				- **大于等于（>=）**
				- **小于等于（<=）**
			- **逻辑运算符**：
				- **与（&&）**
				- **或（||）**
			- **位运算符**：
				- **按位与（&）**
				- **按位或（|)**
				- **按位异或（^）**
				- **左移（<<）**
				- **右移（>>）**
			- **赋值运算符**：
				- **等于（=）**
				- **加等于（+=）**
				- **减等于（-=）**
				- **乘等于（*=）**
				- **除等于（/=）**
				- **取模等于（%=）**
			- **逗号运算符**：
				- **逗号（,）**
			- **三元条件运算符**：
				- **三元条件运算符（?:）**
			- **成员访问运算符**：
				- **点号（.）**
				- **箭头（->）**
			- **sizeof运算符**：
				- **sizeof**
		- **类型转换**：
			- **隐式转换**：
				- `int ival=3.541+3;` 在这个运算中，**3.514是double，3是int，在进行计算的时候会转化为统一的类型后再求值，隐式转换。**
				- **隐式转换什么时候发生**：
					- **在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型。**
					- **在条件中，非布尔值转化为布尔类型。**
					- **初始化过程中，初始值转换为变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。**
					- **如果算术运算或关系运算的运算对象有多种类型，需要转换为同一种类型。**
					- **函数调用时也会发生类型转换。**
			- **算术转换**：
				- **整型提升**：负责将小整数类型转换成较大的整数类型，**前提是转换后的类型要能容纳原类型所有可能的值**。
				- **无符号类型的运算对象**：如果运算类型是无符号，转换结果和机器有关系。
				- **显示转换**：
					- cast-name< type >(expression)
						- type是转换的目标类型
						- expression是要转换的值
						- cast-name：
							- **static_cast**：**任何具有明确定义的类型转换，不要不包含底层const都可以**
								- `double slope=static_cast<double>(j)`
							- **dynamic_cast**：**运行时进行安全的类型转换。**
							- **const_cast**：**只能改变运算对象的底层const**
								- `const char *;`
								  `char *p=const_cast<chat*>(pc);`
							- **reinterpret_cast**：**为运算对象的位模式提供较低层次上的重新解释。**
								- `int *ip;*`
								- `char *pc=reinterpret_cast<char*>(ip;)`
					- **旧式的强制类型转换**：
						- `type (expr);` 函数形式的强制类型转换
						- `(type) expr; char *pc=(char*) ip;` C语言风格的强制类型转换
	- **语句**：
		- **简单语句**：
			- **表达式语句**：
				- `ival+5;`
			- **空语句**：
				- `;`
				- **分号记得写**
		- **条件语句**：
			- `if`语句：
				- `if(condition) statement` 
				- `if(condition) statement else statement2`
				- condition条件，statement是运行的内容
			- `switch`语句：
				- ```switch(ch){case 'a':++aCnt; break;default:++cCnt;break;}``` 
		- **迭代语句**：
			- `while(condition) statement` 
			- `for(init-statment;condition;expression)statement;` 
				- **init-statement**：负责初始化一个值。
				- **condition**：作为循环控制的条件，condition为真，执行一次statement。假的话就不会运行。
				- **expression**：负责修改init-statement初始化的变量。
				- **statement**：是执行的语句。
			- `for(declaration:expression) statment;` 
				- **expression**必须是一个序列。
				- **declaration**定义一个变量，去遍历expreesion中的元素。
			- `do statment;while(condition);` 
				- 执行一次之后，再去判断condition是否符合循环条件。
		- **跳转语句**：
			- `break` 负责终止离它最近的while，do while，for或switch语句，彻底终止循环。
			- `continue` 终止最近的循环中的当前迭代并开始下一次迭代。
			- `goto` 从goto语句无条件跳转到同一函数内的另一条语句。
				- `goto label; label: printf("test")` 直接跳转到label：printf("test")的位置。
		- **try语句块和异常处理**：
			- **异常**：是指**存在于运行时的反常行为，这些行为超出了函数正常功能的范围。**
			- **当运行出现异常的时候，需要进行异常处理**。
				- `throw` 异常检测部分使用throw表达式来表示它遇到了无法处理的问题，这时候throw引发了异常。
				- `try` 异常处理部分使用try语句块处理异常，从try开始，一个或多个`catch` 结束。
				- `try{program-statements} catch(exception-declaration){handle-statements}` 
			- **标准异常**：
				- `#include<exception>` 定义了最通用的异常类exception，只报告出现了异常，不提供任何额外信息。
				- `#include<stdexcept>` 定义了几种常见的异常类。
					- `exception` 最常见的问题
					- `runtime_error` 只有在运行时才能检测出的问题
					- `range_error` 运行时错误：生成的结果超出了有意义的值域范围
					- `overflow_error` 运行时错误：计算上溢
					- `underflow_error` 运行时错误：计算下溢
					- `logic_error` 程序逻辑错误
					- `domain_error` 逻辑错误：参数对应的结果值不存在
					- `invalid_argument` 逻辑错误：无效参数
					- `length_error` 逻辑错误：试图创建一个超出该类型最大长度的对象
					- `out_of_range` 逻辑错误：使用一个超出有效范围的值
				- `#include<new>` 定义了bad_alloc异常类型，即内存问题。
				- `#include<type_info>` 定义了bad_cast异常类型。
	- **函数**：
		- 由**返回类型，函数名字，零个或多个形参组成的列表以及函数体** 组成。通过**调用函数符()** 来执行函数。
		- 当**实参**可以被隐式转换为**形参**的类型时就可以正常调用。
		- **函数定义**：
			- `void f1() == void f2(void)` 都是定义空形参列表
			- `void f3(int i,int j)` 定义有形参列表
		- **参数传递**：
			- **传值参数**：
				- 对形参做的参数不会影响实参。
				- 指针形参：指针形参会影响指针所指位置的值。
			- **传引用参数**：
				- 函数引用形参，对引用形参的改变会改变实参。
				- 如果函数需要同时返回多个值，两种方法：
					- 定义一个新的数据类型，让他包含位置和数量两个成员。
					- 可以给函数传入一个额外的引用实参。
			- **const形参和实参**：当用实参初始化形参会忽略顶层。
			- **数组形参**：
				- **数组特殊性质**：
					- 不允许拷贝数组。
					- 使用数组的时候通常会将其转换成指针。
				- 传递多维数组：
					- `void print(int (*maxtrix)[10])`
			- **main：处理命令行选项**：
				- 可以通过两个可选形参传递给main函数
					- `int main(int argc,char *argv[])` 
						- argc表示数组中字符串的数量。
						- argv是一个数组，指向char*。
						- argv[0]保存程序的名字，之后的才是用户的输入。
			- **含有可变形参的函数**：
				- **initializer_list**：实参数量未知，而类型相同。
					- `initializer_list<T> lst;` 默认初始化，T类型元素的空列表
					- `initializer_list<T> lst{a,b,c...};` lst的元素数量和初始化一样多，lst的元素是对应初始值的副本，列表中的元素是const
					- `lst2(lst) / lst2=lst` 拷贝或赋值一个initializer_list对象不会拷贝列表的元素，拷贝后，原始列表和副本共享元素。
					- `lst.size()` 列表中的元素数量
					- `lst.begin()` 返回指向lst中首元素的指针
					- `lst.end()` 返回指向lst中尾元素下一位置的指针
				- **省略符形参**：
					- `void foo(...);` 省略符形参所对应的实参无需类型检查。
			- **返回类型和return语句**：
				- return语句终止当前执行的函数并将控制权返回到调用该函数的地方
					- `return;/ return expression;`
				- **无返回值函数**：
					- 没有返回值的return语句只能用在返回类型是void的函数。但可以不显式写出来。
				- **有返回值函数**：
					- `return expression;`
					- **值是如何被返回的**：
						- 返回的值用于初始化调用点的一个临时量。临时量就是函数调用的结果。
					- **不要返回局部对象的引用或指针**：
						- **函数完成时，所占用的存储空间也随之被释放掉，所以函数终止意味着局部变量的引用将指向不再有效的内存区域。**
					- **返回数组指针**：
						- 数组函数之间传递就是通过指针的。
		- **函数重载**：
			- **重载函数**：同一作用域几个函数名字相同但形参列表不同。
				- `void print(const char *cp);` 
				- `void print(const int *beg,const int *end);`
				- `void print(const int ia[],size_t size);`
				- **编译器会根据传递的实参类型推断想要的是哪个函数**。
				- **重载函数要形参不一样，而其他不能变**。
				- **如果函数名一样，返回类型不一样，这样定义函数会出错。**
		- **函数相关的语言特性**：
			- **默认实参**：调用默认实参的函数时，可以包含也可以省略。
				- `void gret(std::string name="Guest")`
					- `gret() 使用默认参数`
					- `gret("Alice") 使用提供的值`
			- **内联函数**：关键字**inline**定义一个内联函数，内联函数和普通函数区别在于，内联函数相当于直接将代码复制到对应的位置。可以减少函数调用的开销。
			- **constexpr函数**：**能用于常量表达式的函数**
				- **constexpr函数返回类型及所有形参类型都是字面值类型。**
				- **有且只有一条return语句。**
			- **通常内联函数和constexpr函数用在头部**。
		- **assert预处理宏**：
			- 其实是一个预处理变量
				- `assert(expr)` 对expr求值。
					- 如果表达式为假，assert输出信息并终止程序的执行。
					- 如果表达式为真，assert什么也不做。
					- 定义在`#include<cassert>` 预处理器由预处理器管理。
					- assert依赖于名为NDEBUG的预处理变量的状态。定义了NDEBUG，assert什么也不做，默认状态没有定义NDEBUG。此时assert将执行运行时检查。
					- 可以用`#define` 语句定义NDEBUG，关闭调试状态。也由命令行选项可以定义预处理变量.
					- `cc -D NDEBUG main.c # use /D with the Microsoft compiler` 等价于在main.c文件一开始写#define NDEBUG。
		- **实参类型转换**：
			- 为了实现最佳匹配，编译器将实参类型到形参类型划分几个等级
				- 精确匹配
					- 实参类型和形参类型相同。
					- 实参从数组类型或函数类型转换成对应的指针类型。
					- 向实参添加顶层const或者从实参中删除顶层const。
				- 通过const转换实现的匹配。
				- 通过类型提升实现的匹配。
				- 通过算术类型转换或指针转换。
				- 通过类类型转换实现的匹配。
		- **函数指针**：
			- 函数指针指向的是函数而非对象。函数指针指向某种特定类型（**函数的类型由它的返回类型和形参类型共同决定**）
				- `bool lengthCompare(const string &,const string &);` 声明一个函数。
				- `bool (*pf)(const string &,const string &);` 声明一个函数指针。
					- pf就是一个指向函数的指针，指向的函数参数为(const string &,const string &); 
					- `pf=lengthCompare / pf=&lengthCompare` 
				- **重载函数的指针**
					- 使用重载函数时，上下文必须清晰界定应该选用哪个函数
						- `void ff(int *);` 
						- `void ff(unsigned int);`
						- `void (*pf1)(unsigned int)=ff;`
				- **返回指向函数的指针**：
					- `int add(int a,int b){return a+b;}`加法函数
					- `int subtract(int a,int b){return a-b;}` 减法函数
					- `typedef int (*ArithmeticFunction)(int,int)` 声明一个函数指针类型
					- `ArithmeticFunction test(形参){return add;}` 返回指向函数的指针的函数。
	- **类**：
		- 基本思想是**数据抽象**和**封装**，数据抽象是一种依赖于**接口**和**实现**分离编程技术。
		- **成员函数/方法**：
			- 定义为类的一部分的函数。使用**点运算符（.）** 来访问对象中的成员。
			- 当我们调用成员函数时，实际是替某个对象调用它。
			- this指针指向当前对象的地址。当我们访问对象中的成员函数就是隐式的通过this去调用。
			- **定义一个返回this对象的函数**：
				- `Sales_data& Sales_data::combine(const Sales_data &rhs){return *this;}`
			- **可以在类中声明成员函数，可以在类外定义**
				- `class MyClass { public: // 声明成员函数 void memberFunction(); private: int data; };`
				- `// 定义成员函数 void MyClass::memberFunction() { // 实现函数逻辑 // 可以使用类的成员变量 data }`
			- **构造函数**：每个类分别定义了它的对象被初始化的方式，类通过**一个或几个特殊的成员函数来控制其对象的初始化过程**，这些函数就是**构造函数**。
				- 作用：初始化类对象的数据成员，**无论何时只要类的对象被创建，执行构造函数（不能被声明成const的）**。
				- 当没有函数去进行初始化类对象的数据成员的时候，类通过一个特殊的构造函数控制默认初始化过程，这个函数是**默认构造函数**。
			- **访问控制于封装**：
				- **public**：说明符之后的成员在整个程序内可被访问，**public成员定义类的接口**。
				- **private**：说明符之后的成员**可以被类的成员函数访问**，但是类外的无法访问。
			- **class和struct关键字**：
				- 两个关键字唯一区别就是**默认的访问权限**。
				- **class**默认的访问权限是private
				- **struct**默认的访问权限是public
			- **友元**：允许其他类或者函数访问**非公有成员**，**通过令其他类或者函数成为它的友元**。
			- **声明静态成员**：
				- 静态成员在所有对象中共享。静态成员函数不与任何对象绑定一起，它们不包含this指针。
- **C++标准库**：
	- **IO库**：
		- **IO类**：w开头为宽字符
			- 头文件`iostream`：
				- **istream，wistream**从流读取数据
				- **opstream，wostream**向流写入数据
				- **iostream，wiostream**读写流
			- **IO对象无拷贝或赋值**:
				- `ofstream out1,out2;`
				- **以下都是错误的**：
					- `out1=out2;`
					- `ofstream print(ofstream);`
					- `out2=print(out2);`
			- **条件状态**：IO操纵可能发生错误，有些错误可恢复，有些错误存在与系统（超出应用程序范围）。下列的表是定义的函数与标志。std::ios::
				- `iostate`:提供了表达条件状态的完整功能
				- `badbit`：指出流已崩溃
				- `failbit`：IO操作失败
				- `eofbit`：流到达文件结束
				- `goodbit`：流未处于错误状态，这个值保证为0
				- `s.eof()`：若流s的eofbit置位，则返回true
				- `s.fail()`：若流s的failbit或badbit置位，则返回true
				- `s.bad()`：若流s的badbit置位，则返回true
				- `s.good()`：若流s处于有效状态，则返回true
				- `s.clear()`：将流s中所有条件状态位复位，将流的状态设置为有效，返回void。
				- `s.clear(flags)`：根据给定的flags标志位，将流s对应条件状态位复位，flags的类型为strm::iostate，返回void
				- `s.setstate(flags)`：根据给定的flags标志位，将流s对应条件状态位置位，flags的类型为strm::iostate，返回void
				- `s.rdstate()` 返回流s的当前条件状态，返回值类型为strm::iostate
			- **管理输出缓冲**：
				- 每个输出流都管理一个缓冲区（用来保存程序读写的程序）。
				- **缓冲刷新（数据真正写到输出设备或文件）**：
					- 程序正常结束，作为main函数的return操作一部分，缓冲刷新被执行。
					- 缓冲区满时，需要刷新缓冲，之后新的数据才能继续写入缓冲区。
					- 我们可以使用操作符**endl**，来显式刷新缓冲区。
					- 在每个输出操作之后，用**unitbuf**设置流的内部状态，来清空缓冲区。默认情况下，对cerr时设置unitbuf的。**所以写到cerr的内容都是立即刷新的。**
					- 一个输出流可能被关联到另一个流。这种情况，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况，cin和cerr都关联到cout。**所以读cin或写cerr都会导致cout的缓冲区被刷新。**
				- **刷新输出缓冲区**：
					- **endl**：输出对应内容和一个换行，然后刷新缓冲区。
					- **flush**：输出对应内容，然后刷新缓冲区，不附加任何额外字符。
					- **ends**：输出对应内容和一个空字符，刷新缓冲区。
					- **unitbuf**：每次输出操作后都刷新缓冲区。
						- `cout<<unitbuf` 所有输出操作后都会立即刷新缓冲区。可以说是无缓冲了
						- `cout<<nounitbuf` 回到正常的缓冲方式
		- **文件输入输出**：
			- `#include<fstream>` 
			- 头文件`fstream`：
				- **ifstream，wifstream**从文件读取数据
				- **ofstream，wofstream**向文件写入数据
				- **fstream，wfsteam**读写文件
				- `fstream fstrm;` 创建一个未绑定的文件流。
				- `fstream strm(s);` 创建一个fstream，并打开名为s的文件。
				- `fstream fstrm(s,mode)` 与上一个一样，但按指定的mode打开文件。
					- `mode` ：
						- ios::
							- `in` ：以读方式打开
							- `out` ：以写方式打开，会丢弃已有数据
							- `app` ：每次写操作前均定位到文件末尾
							- `ate` ：打开文件后立即定位到文件末尾
							- `trunc` ：截断文件
							- `binary` ：以二进制方式进行IO
				- `fstrm.open(s)` ：打开名为s的文件，并绑定fstrm。
				- `fstrm.close()` ：关闭于fstrm绑定的文件。返回void
				- `fstrm.is_open()` ：返回一个bool值，判断于fstrm关联的文件是否成功打开并未关闭。
		- **string流**：
			- `#include<sstream>`
			- 头文件`sstream`：**这里的string与容器string不一样。**
				- **istringstream，wistringstream**从string读取数据
				- **ostringstream，wostringstream**向string写入数据
				- **stringstream，wstringstream**读写string
	- **容器**：一些特定类型对象的集合。每个容器都定义在一个头文件中。
		- **顺序容器**：为程序员提供了控制元素存储和访问顺序的能力。
			- **PS：所有顺序容器都提供了快速顺序访问元素的能力。现代c++推荐使用标准库容器。**
			- **vector**：可变大小数组，可快速随机访问。**但尾部之外插入或删除元素可能很慢。** 通常来说，vector是最好的选择。
			- **deque**：双端队列，可快速随机访问，**在头尾位置插入/删除速度很快。**
			- **list**：双向链表，可双向顺序访问，**在任何位置进行插入/删除很快。**
			- **forward_list**：单向链表，可单向顺序访问，**在任何位置插入/删除很快。**
			- **array**：固定大小数组，可快速随机访问，**不能添加/删除元素。**
			- **string**：与vector类似，但专门用于保存字符，**随机访问快，在尾部插入/删除快。**
		- **关联容器**：以键-值对的形式存储元素，并提供一种通过键快速查找、插入或删除元素的机制。
			- **关键字有序**：
				- **map**：关联数组：保存关键字-值对
				- **set**：关键字即值，只保存关键字的容器
				- **multimap**：关键字可重复出现的map
				- **multiset**：关键字可重复出现的set
			- **关键字无序**：
				- **unordered_map**：用哈希函数组织的map
				- **unordered_set**：用哈希函数组织的set
				- **unordered_multimap**：哈希组织的map，关键字可以重复出现
				- **unordered_multiset**：哈希组织的set，关键字可以重复出现
		- **容器操作**：
			- `vector<int>::类型别名 容器名` 
				- `vector<int>::iterator it;`
			- `swap` ：
				- `a.swap(b)/swap(a,b)` 交换a，b元素。
			- **大小** ：
				- `c.size()` c中元素的数目(不适用forward_list)
				- `c.max_size()` c可保存最大元素数目
				- `c.empty()` 判断c是否为空
			- **添加/删除元素**（**array不适用**）：
				- `c.insert(args)` 将args中的元素拷贝进c
				- `c.emplace(inits)` 使用inits构造c中的一个元素
				- `c.erase(args)` 删除args指定的元素
				- `c.clear()` 删除c中所有元素，返回void
			- **迭代器**：
				- `c.begin()/c.end()` 返回指向c的首元素和尾元素之后位置的迭代器
				- `c.cbegin()/c.cend()` 返回const_iterator
			- **反向容器的额外成员**（**不支持forward_list**）：
				- `reverse_iterator` 按逆序寻址元素的迭代器
				- `const_reverse_iterator` 不能修改元素的逆序迭代器
				- `c.rbegin()/c.rend()` 返回指向c的尾元素和首元素之前位置的迭代器
				- `c.crbegin()/c.crend()` 返回const_reverse_iterator
	- **泛型算法**：
	- **动态内存**：
- **类设计者的工具**：
	- **拷贝控制**：
	- **重载运算与类型转换**：
	- **面向对象程序设计**：
	- **模板与泛型编程**：
- **高级主题**：
	- **标准库特殊设施**：
	- **用于大型程序的工具**：
	- **特殊工具与技术**：