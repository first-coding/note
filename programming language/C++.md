- **输入与输出**：cin标准输入，cout标准输出
	- 头文件iostream为标准输入/输出库。
	- 运算符：
		- **输出运算符**：ostream对象<< 需要打印的值
			- **endl**：是一个操纵符，结束当前行，将缓冲区内容刷新到设备中。
		- **输入运算符**：istream对象>>运算对象
- **基础**：
	- **变量和基本类型**：
		- **基本内置类型**：
			- **算术类型**：
				- **整型**：包括字符和布尔类型在内，**数字表示标准规定的最小值**，但是不同机器存在差异。
					- 布尔：**bool**
					- 字符：**char（8位）**
					- 宽字符：**wchar_t（16位）**
					- Unicode字符：
						- **char16_t：16位**
						- **char32_t：32位**
					- 短整型：**short （16位）**
					- 整型：**int （16位）**
					- 长整型：**long（32位）**
					- 长整型：**long long （64位）**
				- **浮点型**：
					- 单精度浮点数：**float （6位有效数字）**
					- 双精度浮点数：**double （10位有效数字）**
					- 扩展精度浮点数：**long double（10位有效数字）**
				- **默认都是带符号的，使用关键字unsigned表示无符号的。无符号只能表示>0的数字。**
			- **空类型**：**void**
		- **类型转换**：
			- 如果转换的类型数值大小不够大的时候，可能会出错，导致程序崩溃，或者生成垃圾数据。
		- **字面值常量**：就是一个值，分为
			- **整型和浮点型**，例如：3.14159，3.14159E0
			- **字符和字符串字面值**，例如：‘a’，“Hello world！”
			- **转义序列**：'\n','\v','\a'.......
			- **布尔字面值和指针字面值**：nullptr是指针字面值，false这种是布尔字面值。
		- **变量**：
			- 定义基本形式：**类型说明符**+**一个或多个变量名组成的列表**+**；**。eg：`int a；`
			- 对象是什么：指的是**一块能存储数据并具有某种类型的内存空间。**
			- **变量初始化**：**当对象在创建时获得一个特定的值**。就说对象被**初始化**。
			- **初始化和赋值**：
				- 初始化：是创建变量时赋予一个初始值。
				- 赋值：把对象当前值擦除，用一个新值替代。
			- **列表初始化**：
				- 可以用{}进行列表初始化.
					- `int sold = {0};`
					- `int sold{0};`
					- `int sold(0);`
			- **默认初始化**：定义变量没有指定初值，则变量被默认初始化。默认值是多少由变量类型决定。
			- **声明和定义关系**：
				- 声明：名字为程序所知，**一个文件如果想使用另一个文件定义的变量则必须需要在文件中进行声明**。
				- 定义：**负责创建与名字关联的实体。**
				- 声明与定义：
					- 声明（extern关键字）：`extern int i`;
					- 定义：`int i / int j=1;`
					- 变量只能被定义一次，但是可以被多次声明。
			- **标识符**：由字母，数字和下划线组成，必须以字母或者下划线开头。没有长度限制，但有大小写区别。
			- **复合类型**：
				- **指针**：是“指向”另外一种类型的复合类型。指针也实现了对其他对象的间接访问，**指针是一个对象，允许赋值和拷贝。** **指针可以无须一定要进行初始化，没有被初始化也会有不确定的值。**
					- 定义指针类型为 `*d` ,d为变量名，每个变量前面必须有符号 `*` 。
					- 获取对象的地址，需要用**取地址符(&)**。
						- `int ival=42;int *p = &ival;`
					- 指针的值（即地址），4中状态之一
						- **指向一个对象。**
						- **指向紧邻对象所占空间的下一个位置。**
						- **空指针，意味着指针没有指向任何对象。**
							- `int *p=nullptr` # 这是c++11新标准
							- `int *p2=0`
							- `int *p3=NULL` # 需要加入头文件 cstdlib，它的值是0。
						- **无效指针，也就是上述情况之外的其他值。**
					- void* 指针：
						- 是一种特殊的指针类型，可用于存放任意对象的地址。
					- 利用指针访问对象
						- `int ival=42; int *p = &ival; cout << *p;`
						- 解引用(操作符*)访问该对象；`*p` 得到该指针p所指的对象，输出42。
				- **引用**：**为对象起另外一个名字**，引用类型引用另外一种类型，**通过将声明符写成&d的形式来定义引用类型**。d是声明的变量名。就是把引用和它的初始值绑定在一起。（**引用必须被初始化**）。
					- PS：
						- **不能定义引用的引用。**
						- **引用必须要是同一种类型说明符，对int对象的引用也要是int类型的引用。**
					- eg:
						- `int i=1024; ` # 这是定义了一个变量。
						- `int &r = i;` # 这是引用，与i绑定在一起。
				- **对指针的引用**：`int *p; int *&r=p;(对指针的引用)`
			- **const 限定符**：**const关键字声明的变量值不能被改变。**
				- 当多个文件使用的时候，默认只在文件内有效，想解决这个问题用
					- `extern const int bufSize;`
					- 对于const变量不管是声明还是定义都添加extern关键字。
					- ps：想要知道什么是常量建议从右往左读。
			- **constexpr关键字**：**指值不会改变并且在编译过程就能得到计算结果的表达式。**
			- **const和constexpr**：
				- const：
					- 用于声明不可变的变量。
					- 防止修改函数参数或返回值。
					- 声明常量，指针等。
					- 运行时常量，值在运行时确定。
					- 不要求在编译时计算值。
					- eg:
						- `const int x = 5; // 不可变的变量`
						- `void foo(const int y); // 防止修改的函数参数`
				- constexpr:
					- 用于声明在编译时计算出值的常量表达式。
					- 可用于函数、变量。
					- 编译时常量，值在编译时确定。
					- 要求在编译时计算值。
					- eg:
						- `constexpr int x = 5; // 编译时常量`
						- `constexpr int square(int x) { return x * x; } // 编译时计算的函数`
			- **类型别名**：
				- **typedef**：`typedef double wages;`
				- **using**：`using SI = Sales_Item;`
				- **这两种方式都是给类型起其他名字。**
			- **auto类型说明符**：
				- **auto**：让编译器分析表达式所属的类型。
					- `auto i=0;` 自动推算i的类型。
			- **decltype类型指示符**：
				- decltype：从表达式的类型推断出要定义的变量类型。
					- `decltype (f()) sum = x;` sum的类型就是函数f的返回类型。
			- **预处理器**：
				- `#define` 指令把一个名字设定为预处理变量。
				- `#ifdef` 当且仅当变量已定义时为真。
				- `#ifndef` 当且仅当变量未定义为真。
					- 一旦检查结果为真，则执行后续操作直至遇到`#endif`为止。
	- **字符串、向量和数组**：
		- **命令空间的using声明**：
			- `using namespace::name` 这样可以在namespace中使用name这个对象。
			- ps：当使用`using namespace std` 就不需要再每个对象都导入了。std命令空间中所有函数和对象都可以不需要`std::name` 这样使用了。可以直接`name` 这个样子了。
		- **标准库类型string**：
			- `#include<string>  using std::string`
			- **定义string对象**
				- `string s1;`
				- `string s2 = s1`
				- `string s3 = "hiya";`
				- `string s4(10,'c');` s4的内容是10个c
			- **初始化string对象**：
				- **拷贝初始化**：用等号=初始化一个变量。
					- `string s5="hiya";` 
					- `string s8= string(10,'c')`
				- **直接初始化**：不用等号的话就是直接初始化。
					- `string s6("hiya");`
					- `string s7(10,'c');`
			- **string对象上的操作**：
				- `os<<s`  将s写到输出流os当中，返回os
				- `is>>s`  从is中读取字符串赋给s，字符串以空白分隔，返回is
				- `getline(is,s)` 从is中读取一行赋给s，返回is
				- `s.empty()` s为空返回true，否则返回false
				- `s.size()` 返回s中字符的个数
				- `s[n]` 返回s中第n个字符的引用，从0开始计起
				- `s1+s2` 返回s1和s2连接后的结果
				- `s1=s2` 用s2的副本代替s1中原来的字符
				- `s1==s2 / s1!=s2` 如果s1和s2中所含的字符一样，则它们相等；string对象的相等性判断对字母的大小敏感。
				- `<,<=,>,>=` 利用字符在字典中的顺序进行比较，且对字母的大小写敏感。
			- **empty与size**：
				- empty函数根据string对象是否为空返回一个对应的布尔值。
				- size函数返回string对象的长度。返回的类型为string::size_type类型
			- `string s1; cin >> s1; cout << s1 << endl;` 读取string对象，遇到空白就停止
			- `string s1,s2; cin >> s1 >> s2; cout << s1 << s2 << endl；` 多个变量输入与输出
			- `string word; while(cin >> word){cout << word << endl;}` 读取未知数量的string对象
			- `string line; while(getline(cin,line)){cout << line << endl;}` getline读取一整行
			- **处理string对象中的字符**
				- `#include<cctype>` 
					- `isalnum(c)` 当c是字母或数字时为真
					- `isalpha(c)` 当c是字母时为真
					- `iscntrl(c)` 当c是控制字符时为真
					- `isdigit(c)` 当c是数字时为真
					- `isgraph(c)` 当c不是空格但可打印时为真
					- `islower(c)` 当c是小写字母时为真
					- `isprint(c)` 当c是可打印字符时为真(即c是空格或c具有可视形式)
					- `ispunct(c)` 当c是标点符号时为真（即c不是控制字符，数字，字母，可打印空白中的一种）
					- `isspace(c)` 当c是空白时为真（即c是空格，横向制表符，纵向制表符，回车符，换行符，进纸符中的一种）
					- `isupper(c)` 当c是大写字母时为真
					- `isxdigit(c)` 当c是十六进制数字时为真
					- `tolower(c)` 如果c是大写字母，输入对应的小写字母，否则原样输出c
					- `toupper(c)` 如果c是小写字母，输出对应的大写字母，否则原样输出c
				- **范围的for语句**：
					- for(declaration: expression)
						- declaration：定义一个变量，用于访问序列中的基础元素。
						- expression：是一个对象，用于表示一个序列。
				- **下标运算符 ( `[]` )**:
					- `[]` 接收的输入参数为string::size_type类型的值。
		- **标准库类型vector**：
			- **vector**表示对象的集合，其中所有对象的类型都相同，也叫容器
				- `#include<vector> using std::vector` 
				- `vector<int> ivec;` ivec保存int类型的对象
				- `vector<Sales_item> Sales_vec;` 保存Sales_item类型的对象
				- `vector<vector<string>> file` 该向量的元素是vector对象
			- **定义和初始化vector对象**：
				- `vector<T> v1` v1是一个空vector，元素类型是T，执行默认初始化
				- `vector<T> v2(v1)` v2中包含有v1所有元素的副本
				- `vector<T> v2=v1` 等价于v2(v1)，v2中包含有v1所有元素的副本
				- `vector<T> v3(n,val)` v3包含n个重复的元素，每个元素的值都是val
				- `vector<T> v4(n)` v4包含n个重复地执行了值初始化的对象
				- `vector<T> v5{a,b,c...}` v5包含了初始值个数的元素，每个元素被赋予相应的初始值
				- `vector<T> v5={a,b,c,...}` 等价于v5{a,b,c,...}
			- **向vector对象中添加元素**：
				- **push_back**：在vector尾端添加新的对象。
					- `vector<string> text; test.push_back(new_word);`
					- `text.empty()` 查看text是否含有元素
					- `text.size()` 返回text中元素的个数
					- `text[n]` 返回text中第n个位置上元素的引用，可用这个返回元素，**但是不可以用这种方式添加元素**
					- `v=text` 将text中的元素拷贝替换v的元素
					- `v={a,b,c...}` 用列表中元素的拷贝替换v中的元素
					- `v1==v2 / v1!=v2 / <,<=,>,>=` 比较
		- **迭代器（iterator）**：**所有标准库容器都可以使用迭代器，但是string也可以使用迭代器**。
			- 使用迭代器：`auto b=v.begin(),e=v.end()` begin是v第一个元素，end是容器v尾元素的下一个位置。
			- **迭代器运算符**：
				- `*iter`：返回迭代器iter所指元素的引用
				- `iter->mem`：解引用iter并获取该元素的名为mem的成员，等价于`(*iter).mem` 
				- `++iter`：令iter指示容器中的下一个元素
				- `--iter`：令iter指示容器中的上一个元素
				- `iter1== / ！= iter2` 都是判断这两个容器是否相等
		- **数组**：
			- **定义和初始化内置数组**：
				- `int arr[10];` 含有10个整数的数组
				- `constexpr unsigned sz=42;int *parr[sz];` 含有42个整型指针的数组
			- **显式初始化数组元素**：
				- `const unsigned sz=3; int ia1[sz]={0,1,2}; int a2[]={0,1,2};`
				- **不允许使用一个数组初始化另一个数组。**
			- 指针和数组与c一样。
			- **C风格字符串**：
				- `include<cstring>` cstring是C语言头文件string.h的C++版本
					- `strlen(p)` 返回p的长度，空字符不计算在内
					- `strcmp(p1,p2)` 比较p1和p2.
					- `strcat(p1,p2)` 将p2附加到p1之后，返回p1
					- `strcpy(p1,p2)` 将p2拷贝给p1，返回p1
			- **大部分操作和C语言类似**
	- **表达式**：
		- **一元运算符**：
			- **递增和递减运算符**：
				- **递增（++）**：对象加一
				- **递减（--）**：对象减一
			- **正负号运算符**：
				- **正号（+）**
				- **负号（-）**
			- **逻辑非运算符**：
				- **非（！）**
			- **按位取反运算符**:
				- **按位取反（~）**
			- **地址和解引用运算符**：
				- **取地址（&）**
				- **解引用（ * ）**
		- **二元运算符**：
			- **算术运算符**：
				- **加法（+）**
				- **减法（-）**
				- **乘法（ * ）**
				- **除法（/）**
				- **取模（%）**
			- **关系运算符**：
				- **等于（ == ）**
				- **不等于（!=）**
				- **大于（>）**
				- **小于（<）**
				- **大于等于（>=）**
				- **小于等于（<=）**
			- **逻辑运算符**：
				- **与（&&）**
				- **或（||）**
			- **位运算符**：
				- **按位与（&）**
				- **按位或（|)**
				- **按位异或（^）**
				- **左移（<<）**
				- **右移（>>）**
			- **赋值运算符**：
				- **等于（=）**
				- **加等于（+=）**
				- **减等于（-=）**
				- **乘等于（*=）**
				- **除等于（/=）**
				- **取模等于（%=）**
			- **逗号运算符**：
				- **逗号（,）**
			- **三元条件运算符**：
				- **三元条件运算符（?:）**
			- **成员访问运算符**：
				- **点号（.）**
				- **箭头（->）**
			- **sizeof运算符**：
				- **sizeof**
		- **类型转换**：
			- **隐式转换**：
				- `int ival=3.541+3;` 在这个运算中，**3.514是double，3是int，在进行计算的时候会转化为统一的类型后再求值，隐式转换。**
				- **隐式转换什么时候发生**：
					- **在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型。**
					- **在条件中，非布尔值转化为布尔类型。**
					- **初始化过程中，初始值转换为变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。**
					- **如果算术运算或关系运算的运算对象有多种类型，需要转换为同一种类型。**
					- **函数调用时也会发生类型转换。**
			- **算术转换**：
				- **整型提升**：负责将小整数类型转换成较大的整数类型，**前提是转换后的类型要能容纳原类型所有可能的值**。
				- **无符号类型的运算对象**：如果运算类型是无符号，转换结果和机器有关系。
				- **显示转换**：
					- cast-name< type >(expression)
						- type是转换的目标类型
						- expression是要转换的值
						- cast-name：
							- **static_cast**：**任何具有明确定义的类型转换，不要不包含底层const都可以**
								- `double slope=static_cast<double>(j)`
							- **dynamic_cast**：**运行时进行安全的类型转换。**
							- **const_cast**：**只能改变运算对象的底层const**
								- `const char *;`
								  `char *p=const_cast<chat*>(pc);`
							- **reinterpret_cast**：**为运算对象的位模式提供较低层次上的重新解释。**
								- `int *ip;*`
								- `char *pc=reinterpret_cast<char*>(ip;)`
					- **旧式的强制类型转换**：
						- `type (expr);` 函数形式的强制类型转换
						- `(type) expr; char *pc=(char*) ip;` C语言风格的强制类型转换
	- **语句**：
		- **简单语句**：
			- **表达式语句**：
				- `ival+5;`
			- **空语句**：
				- `;`
				- **分号记得写**
		- **条件语句**：
			- `if`语句：
				- `if(condition) statement` 
				- `if(condition) statement else statement2`
				- condition条件，statement是运行的内容
			- `switch`语句：
				- ```switch(ch){case 'a':++aCnt; break;default:++cCnt;break;}``` 
		- **迭代语句**：
			- `while(condition) statement` 
			- `for(init-statment;condition;expression)statement;` 
				- **init-statement**：负责初始化一个值。
				- **condition**：作为循环控制的条件，condition为真，执行一次statement。假的话就不会运行。
				- **expression**：负责修改init-statement初始化的变量。
				- **statement**：是执行的语句。
			- `for(declaration:expression) statment;` 
				- **expression**必须是一个序列。
				- **declaration**定义一个变量，去遍历expreesion中的元素。
			- `do statment;while(condition);` 
				- 执行一次之后，再去判断condition是否符合循环条件。
		- **跳转语句**：
			- `break` 负责终止离它最近的while，do while，for或switch语句，彻底终止循环。
			- `continue` 终止最近的循环中的当前迭代并开始下一次迭代。
			- `goto` 从goto语句无条件跳转到同一函数内的另一条语句。
				- `goto label; label: printf("test")` 直接跳转到label：printf("test")的位置。
		- **try语句块和异常处理**：
			- **异常**：是指**存在于运行时的反常行为，这些行为超出了函数正常功能的范围。**
			- **当运行出现异常的时候，需要进行异常处理**。
				- `throw` 异常检测部分使用throw表达式来表示它遇到了无法处理的问题，这时候throw引发了异常。
				- `try` 异常处理部分使用try语句块处理异常，从try开始，一个或多个`catch` 结束。
				- `try{program-statements} catch(exception-declaration){handle-statements}` 
			- **标准异常**：
				- `#include<exception>` 定义了最通用的异常类exception，只报告出现了异常，不提供任何额外信息。
				- `#include<stdexcept>` 定义了几种常见的异常类。
					- `exception` 最常见的问题
					- `runtime_error` 只有在运行时才能检测出的问题
					- `range_error` 运行时错误：生成的结果超出了有意义的值域范围
					- `overflow_error` 运行时错误：计算上溢
					- `underflow_error` 运行时错误：计算下溢
					- `logic_error` 程序逻辑错误
					- `domain_error` 逻辑错误：参数对应的结果值不存在
					- `invalid_argument` 逻辑错误：无效参数
					- `length_error` 逻辑错误：试图创建一个超出该类型最大长度的对象
					- `out_of_range` 逻辑错误：使用一个超出有效范围的值
				- `#include<new>` 定义了bad_alloc异常类型，即内存问题。
				- `#include<type_info>` 定义了bad_cast异常类型。
	- **函数**：
		- 由**返回类型，函数名字，零个或多个形参组成的列表以及函数体** 组成。通过**调用函数符()** 来执行函数。
		- 当**实参**可以被隐式转换为**形参**的类型时就可以正常调用。
		- 函数定义：
			- `void f1() == void f2(void)` 都是定义空形参列表
			- `void f3(int i,int j)` 定义有形参列表
			- 
	- **类**：
- **C++标准库**：
	- **IO库**：
		- **IO类**：w开头为宽字符
			- 头文件iostream：
				- **istream，wistream**从流读取数据
				- **opstream，wostream**向流写入数据
				- **iostream，wiostream**读写流
			- 头文件fstream：
				- **ifstream，wifstream**从文件读取数据
				- **ofstream，wofstream**向文件写入数据
				- **fstream，wfsteam**读写文件
			- 头文件sstream：**这里的string与容器string不一样。**
				- **istringstream，wistringstream**从string读取数据
				- **ostringstream，wostringstream**向string写入数据
				- **stringstream，wstringstream**读写string
			- **IO对象无拷贝或赋值**
			- 条件状态：IO操纵可能发生错误，有些错误可恢复，有些错误存在与系统（超出应用程序范围）。下列的表是定义的函数与标志。std::ios::
				- iostate:提供了表达条件状态的完整功能
				- badbit：指出流已崩溃
				- failbit：IO操作失败
				- eofbit：流到达文件结束
				- goodbit：流未处于错误状态，这个值保证为0
- **类设计者的工具**：
- **高级主题**：