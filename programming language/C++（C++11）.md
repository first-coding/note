- **基础**：
	- **变量和基本类型**：
		- **基本内置类型**：
			- **算术类型**：
				- **整型**：包括字符和布尔类型在内，**数字表示标准规定的最小值**，但是不同机器存在差异。
					- 布尔：**bool**
					- 字符：**char（8位）**
					- 宽字符：**wchar_t（16位）**
					- Unicode字符：
						- **char16_t：16位**
						- **char32_t：32位**
					- 短整型：**short （16位）**
					- 整型：**int （16位）**
					- 长整型：**long（32位）**
					- 长整型：**long long （64位）**
				- **浮点型**：
					- 单精度浮点数：**float （6位有效数字）**
					- 双精度浮点数：**double （10位有效数字）**
					- 扩展精度浮点数：**long double（10位有效数字）**
				- **默认都是带符号的，使用关键字unsigned表示无符号的。无符号只能表示>0的数字。
			- **空类型**：**void**
		- **类型转换**：
			- 如果转换的类型数值大小不够大的时候，可能会出错，导致程序崩溃，或者生成垃圾数据。
		- **字面值常量**：就是一个值，分为
			- **整型和浮点型**，例如：3.14159，3.14159E0
			- **字符和字符串字面值**，例如：‘a’，“Hello world！”
			- **转义序列**：'\n','\v','\a'.......
			- **布尔字面值和指针字面值**：nullptr是指针字面值，false这种是布尔字面值。
		- **变量**：
			- 定义基本形式：**类型说明符**+**一个或多个变量名组成的列表**+**；**。eg：`int a；`
			- 对象是什么：指的是**一块能存储数据并具有某种类型的内存空间。**
			- **变量初始化**：**当对象在创建时获得一个特定的值**。就说对象被**初始化**。
			- **初始化和赋值**：
				- 初始化：是创建变量时赋予一个初始值。
				- 赋值：把对象当前值擦除，用一个新值替代。
			- **列表初始化**：
				- 可以用{}进行列表初始化.
					- `int sold = {0};`
					- `int sold{0};`
					- `int sold(0);`
			- **默认初始化**：定义变量没有指定初值，则变量被默认初始化。默认值是多少由变量类型决定。
			- **声明和定义关系**：
				- 声明：名字为程序所知，**一个文件如果想使用另一个文件定义的变量则必须需要在文件中进行声明**。
				- 定义：**负责创建与名字关联的实体。**
				- 声明与定义：
					- 声明（extern关键字）：`extern int i`;
					- 定义：`int i / int j=1;`
					- 变量只能被定义一次，但是可以被多次声明。
			- **标识符**：由字母，数字和下划线组成，必须以字母或者下划线开头。没有长度限制，但有大小写区别。
			- **复合类型**：
				- **指针**：是“指向”另外一种类型的复合类型。指针也实现了对其他对象的间接访问，**指针是一个对象，允许赋值和拷贝。** **指针可以无须一定要进行初始化，没有被初始化也会有不确定的值。**
					- 定义指针类型为 `*d` ,d为变量名，每个变量前面必须有符号 `*` 。
					- 获取对象的地址，需要用**取地址符(&)**。
						- `int ival=42;int *p = &ival;`
					- 指针的值（即地址），4中状态之一
						- **指向一个对象。**
						- **指向紧邻对象所占空间的下一个位置。**
						- **空指针，意味着指针没有指向任何对象。**
							- `int *p=nullptr` # 这是c++11新标准
							- `int *p2=0`
							- `int *p3=NULL` # 需要加入头文件 cstdlib，它的值是0。
						- **无效指针，也就是上述情况之外的其他值。**
					- void* 指针：
						- 是一种特殊的指针类型，可用于存放任意对象的地址。
					- 利用指针访问对象
						- `int ival=42; int *p = &ival; cout << *p;`
						- 解引用(操作符*)访问该对象；`*p` 得到该指针p所指的对象，输出42。
				- **引用**：**为对象起另外一个名字**，引用类型引用另外一种类型，**通过将声明符写成&d的形式来定义引用类型**。d是声明的变量名。就是把引用和它的初始值绑定在一起。（**引用必须被初始化**）。
					- PS：
						- **不能定义引用的引用。**
						- **引用必须要是同一种类型说明符，对int对象的引用也要是int类型的引用。**
					- eg:
						- `int i=1024; ` # 这是定义了一个变量。
						- `int &r = i;` # 这是引用，与i绑定在一起。
				- **对指针的引用**：`int *p; int *&r=p;(对指针的引用)`
			- **const 限定符**：**const关键字声明的变量值不能被改变。**
				- 当多个文件使用的时候，默认只在文件内有效，想解决这个问题用
					- `extern const int bufSize;`
					- 对于const变量不管是声明还是定义都添加extern关键字。
					- ps：想要知道什么是常量建议从右往左读。
			- **constexpr关键字**：**指值不会改变并且在编译过程就能得到计算结果的表达式。**
			- **const和constexpr**：
				- const：
					- 用于声明不可变的变量。
					- 防止修改函数参数或返回值。
					- 声明常量，指针等。
					- 运行时常量，值在运行时确定。
					- 不要求在编译时计算值。
					- eg:
						- `const int x = 5; // 不可变的变量`
						- `void foo(const int y); // 防止修改的函数参数`
				- constexpr:
					- 用于声明在编译时计算出值的常量表达式。
					- 可用于函数、变量。
					- 编译时常量，值在编译时确定。
					- 要求在编译时计算值。
					- eg:
						- `constexpr int x = 5; // 编译时常量`
						- `constexpr int square(int x) { return x * x; } // 编译时计算的函数`
			- **类型别名**：
				- **typedef**：`typedef double wages;`
				- **using**：`using SI = Sales_Item;`
				- **这两种方式都是给类型起其他名字。**
			- **auto类型说明符**：
				- **auto**：让编译器分析表达式所属的类型。
					- `auto i=0;` 自动推算i的类型。
			- **decltype类型指示符**：
				- decltype：从表达式的类型推断出要定义的变量类型。
					- `decltype (f()) sum = x;` sum的类型就是函数f的返回类型。
			- **预处理器**：
				- `#define` 指令把一个名字设定为预处理变量。
				- `#ifdef` 当且仅当变量已定义时为真。
				- `#ifndef` 当且仅当变量未定义为真。
					- 一旦检查结果为真，则执行后续操作直至遇到`#endif`为止。
	- **字符串、向量和数组**：
		- **命令空间的using声明**：
			- `using namespace::name` 这样可以在namespace中使用name这个对象。
			- ps：当使用`using namespace std` 就不需要再每个对象都导入了。std命令空间中所有函数和对象都可以不需要`std::name` 这样使用了。可以直接`name` 这个样子了。
	- **表达式**：
	- **语句**：
	- **函数**：
	- **类**：
- **C++标准库**：
	- **IO库**：
		- **IO类**：w开头为宽字符
			- 头文件iostream：
				- **istream，wistream**从流读取数据
				- **opstream，wostream**向流写入数据
				- **iostream，wiostream**读写流
			- 头文件fstream：
				- **ifstream，wifstream**从文件读取数据
				- **ofstream，wofstream**向文件写入数据
				- **fstream，wfsteam**读写文件
			- 头文件sstream：**这里的string与容器string不一样。**
				- **istringstream，wistringstream**从string读取数据
				- **ostringstream，wostringstream**向string写入数据
				- **stringstream，wstringstream**读写string
			- **IO对象无拷贝或赋值**
			- 条件状态：IO操纵可能发生错误，有些错误可恢复，有些错误存在与系统（超出应用程序范围）。下列的表是定义的函数与标志。std::ios::
				- iostate:提供了表达条件状态的完整功能
				- badbit：指出流已崩溃
				- failbit：IO操作失败
				- eofbit：流到达文件结束
				- goodbit：流未处于错误状态，这个值保证为0
- **类设计者的工具**：
- **高级主题**：