- **运输层协议为运行在不同主机上的应用程序之间提供了逻辑通信**。
- **运输层协议实在端系统而不是在路由器上实现。**
- 运输层的分组叫做**报文段**。
- **运输层与网络层关系**：
	- 网络层提供了主机之间的逻辑通信。
	- 类比来说就是相当于间隔很远的两个家庭，每个家庭有12个孩子，两个家庭之间需要进行写信，每个家庭会有一个人负责收发信息（相当于运输层协议），邮政服务（相当于网络层协议）
- **运输层协议**：
	- UDP（用户数据报协议）：为调用的应用程序提供了不可靠、无连接的协议。
	- TCP（传输控制协议）：为调用的应用程序提供一种可靠，面向连接的服务。
	- 进程到进程的数据交付和差错检查是两种最低限度的运输层服务。UDP提供的仅有两种服务。
	- 在最低限度的运输层服务加上提供**可靠数据传输（relia-ble data transfer）**，通过使用**流量控制，序号，确认和定时器**TCP确保正确，按序的将数据从发送进程交付给接收进程。还提供了**拥塞控制（congestion control）**。
- **多路复用和多路分解**：
	- 多路复用：在发送端将多个不同的数据流（通常来自不同应用程序）合并成一个单一的数据流进行传输，这样可以共享网络资源，提高网络的利用率。在运输层，多路复用可以通过使用端口号来实现。每个应用程序或进程都与一个唯一的端口号相关联。当数据从这些应用程序发送时，**运输层将根据端口号将它们合并成一个数据流**，并通过网络传输到目的地。
	- 多路分解：在接收端，当数据到达目的地后，运输层需要根据端口号将数据从单一的数据流中分解出来，然后将其传递给正确的应用程序或进程进行处理。通过这种方式，运输层可以保证数据到达正确的目的地，并交付给正确的应用程序进行处理。
	- 总结起来，多路复用允许将多个数据流合并为一个数据流进行传输，而多路分解则允许在接收端将数据从单一数据流中分解出来，交付给相应的应用程序。这两个过程是运输层实现可靠数据传输的重要机制。
- UDP套接字是一个二元组全面标识的（目的IP地址和一个目的端口号）
- TCP套接字是一个四元组（源IP地址，源端口号，目的IP地址，目的端口号），这四个字段被用来将报文段定向（分解为）到相应的套接字。
- **UDP（用户数据报协议）**：
	- UDP相对于TCP有些应用程序更加适合原因：
		- 关于发送什么数据以及何时发送的应用层控制更精细。
		- 无需建立连接。
		- 无连接状态。
		- 分组首部开销小。每个TCP报文都有20字节的首部大小，而UDP只有8字节的首部大小。
	- 报文段结构：![[Drawing 2023-08-05 16.48.40.excalidraw]]
	- 伪头部，不会被传输：![[Drawing 2023-08-14 15.51.32.excalidraw]]
	- UDP检验和：提供了差错检测功能（但是对差错回复无能为力）。通过UDP伪头部和UDP头部以及UDP数据进行计算。进行反码运算（将所有的0换成1，1换成0）。求和遇到溢出的话会被回卷（将溢出位进位到最低位中）。
- **构造可靠数据传输协议**：
	- **有限状态机（Finite-State Machine，FSM）**：是一种数学模型和计算模型，用于描述系统在不同状态之间转换的行为。它是一种抽象的模型，用于描述具有有限个状态、转移条件和动作的系统的行为。
		- 经完全可靠信道的可靠传输：rdt1.0:
			- 在这种情况下，底层信道是完全可靠的。FSM图如下![[Drawing 2023-08-09 16.41.36.excalidraw]]
		- 经具有比特差错信道的可靠数据传输：rdt2.0：
			- 在这种情况下，底层信道分组的比特可能受损。FSM如下![[Drawing 2023-08-09 17.02.21.excalidraw]]
			- rdt2.1，ACK分组或者NAK分组存在受损的可能性。
				- ACK或者NAK分组受损，解决办法存在三种可能性
					1. 类比我们人可能做法，如果说话者不理解来自接收方回答的“OK”或者“请重复一篇”，说话者会问“你说什么”。如果说话者的“你说什么”产生了差错的话，接收者不明白那一句是什么，所以接收者会回“你说什么”。这时候就会出现一个无尽的循环。
					2. 增加足够的检验和比特，发送方不仅可以差错检测，还能恢复差错，对于不会产生差错不丢失分组的信道，可以直接解决。
					3. 当发送方收到含糊不清的ACK或NAK分组，只需重传当前数据分组即可，然而，这可能导致引出了**冗余分组（duplicate packet）**，接收方不知接收到的分组是新的还重传。
						- 解决这个问题通过让发送方对数据分组编号。分组中加入**序号**字段。接收方通过序号就可以知道是新的分组还是重传了。
					- ![[Drawing 2023-08-09 17.02.10.excalidraw]]
					- 也可以通过发送方接收到同一个分组的两个ACK（冗余ACK）判断是否正确接收分组，rdt2.2就是在具有比特差错信道上实现一个无NAK的可靠的可靠数据传输协议。这样的话就需要对ACK进行编号。![[Drawing 2023-08-10 15.41.28.excalidraw]]
		- 经具有比特差错的丢包信道的可靠数据传输：rdt3.0（比特交替协议，因为分组序号在0和1之间交替）：
			- 在这种情况下，底层信道分组比特除了受损以外，还会丢包。
			- 通过一个超时来进行重传，这个时间只要是一个往返时间和接收方处理一个分组的时间。这个就需要一个倒计数定时器。发送需要做到：
				- 每次发送一个分组（包括第一次分组和重传分组）时，启动一个定时器。
				- 响应定时器中断（采取适当动作）
				- 终止定时器。
			- ![[Drawing 2023-08-10 16.38.20.excalidraw]]
			- ![[Drawing 2023-08-10 17.13.18.excalidraw]]
- **流水线可靠数据传输协议**：发送方（或信道）利用率为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比：Usender=(L/R) / RTT + L/R = 0.008/30.008 = 0.00027（所以发送方利用率非常低） 
	- 假设传播时延为RTT大约为30ms,假定一条发送速率R为1Gbps（每秒10^9比特）信道相连，分组L长为1000字节（8000比特），发送一个分组进入链路的时间为 t = L/R=8000bit/pkt / 10^9bit/s=8μs/pkt。
	- 在30.008ms之后才可以发送下一个报文，在这个30.008ms中，发送方发送只用了0.008ms。 
	- **通过不用停等方式运行，在发送方发送分组后无需等待确认。**，这种技术称为**流水线（pipelining）**，流水线会有一下影响
		- 必须增加序号范围，每一个传输中分组都必须有一个唯一的序号。
		- 协议发送方和接收方两端不得不缓存多个分组。发送方最低限度应当能缓存那些已发送还没确认的分组。接收方也需要缓存那些已正确接收的分组。
		- 所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失，受损及延时过大的分组。流水线解决差错有两种基本方式：
			- **回退N步(Go-Back-N，GBN)**：允许发送方发送多个分组（当有多个分组可用时）而不需要等待确认。未确认的分组数不能超过某个最大值N。
				- 如果基序号（base）定义为最早未确认分组的序号。下一个序号（nextseqnum)定义为最小的未使用序号（下一个代发分组的序号）。则可以将序号范围分割为4段，[0,base-1]已经发送已被确认的分组。[base,nextseqsum-1]发送了未被确认的分组。[nextseqsum,base+N-1]为用于那些要被立即发送的分组。大于或等于base+N是不可用的，直到前面未被确认的分组接收到了确认的报文。（N常被称为窗口长度，GBN协议也经常被称为滑动窗口协议）
				- 实际中，序号的范围是根据分组序号字段的比特数k来决定的，这个序号范围为(0,2^k-1)。序号空间可以看作一个长度为2^k的环。
				- 扩张FSM如下图：
					- ![[Drawing 2023-08-12 14.29.57.excalidraw]]
				- 就是中间n出现了分组丢失，没接收到ACK的话，超时的话，不管后面是否有正确接收到分组。正确接收到了后面的分组的话可能会进行缓存分组n+1，直到n的确认分组到达了之后才会将n+1分组交付到上层，累计确认就是接收到一个有序号n的ACK分组，接收到的话，就意味着n和n之前的分组都接收成功。![[Drawing 2023-08-12 14.53.38.excalidraw]]
			- **选择重传(Selective Repeat，SR）**：通过让发送方仅重传那些丢失或受损的分组。避免了不必要的重传。
- **TCP连接**：提供的是全双工的服务，TCP是点对点的。单个发送方与单个接收方之间的连接。两台主机之间的网络元素（路由器，交换机和中继器）都不会为TCP连接分配缓存和变量。
	- TCP报文段：![[Drawing 2023-08-14 16.30.16.excalidraw]]![[Drawing 2023-08-14 16.00.01.excalidraw]]
	- 连接管理：
		- 三次握手：
			1. 客户端TCP向服务器发送一个特殊的TCP报文段，不包含应用层的数据。在首部的标志位SYN比特置为1，seq（序号）置为随机值x。
			2. 当客户端的报文段到达的时候，服务器提取出里面的SYN报文段，为这个TCP连接分配缓存和变量。并向客户TCP发送允许连接的报文段。（不包含应用层数据），SYN和ACK比特设置为1，确认号（ack）设为x+1。接着服务器设置自己的序号字段y。
			3. 收到服务器发送的报文，客户端分配缓存和变量，并发送最后一个特殊报文段。对服务器的允许连接报文段进行确认。ACK（标志位）字段置为1，SYN字段设为0，seq（序号）字段设为x+1，ack（确认号字段）设为y+1。在这个第三阶段可以携带应用层报文。
			4. 图解如下：![[Drawing 2023-08-21 17.55.58.excalidraw]]
		- 四次挥手：![[Drawing 2023-08-22 16.57.07.excalidraw]]四次挥手是同意对方请求和自身请求分离开。需要四次是因为另一方可能还有数据在路上或者自身还有数据需要发送。
	- 超时/重传机制：
		- SampleRTT：发出数据到接收确认时间（只在第一次测量）
		- EstimatedRTT（SampleRTT均值）：
		  公式：（1-α）. EstimatedRTT+α.SampleRTT 去更新。α推荐为0.125。
		- DevRTT（RTT偏差）：
		  公式：（1-β）. DevRTT + β . | SampleRTT - EstimatedRTT |。β推荐值为0.25。 
		- 设置管理重传超时间隔：
			- TCP：TimeoutInterval = EstimatedRTT + 4.DevRTT，初始值为1秒，如果超时，TimeoutInterval会加倍。当EstimatedRTT的值改变的话，运用公式再次计算。
		- 在TCP中仅使用单一的重传定时器。接收到数据传递IP的时候，定时器开始。
		- **快速重传**：  当发送方接收到对相同数据的3个冗余ACK，这说明在这个3个冗余ACK的报文段之后的报文段已经丢失。这时候执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。
		- 有三种情况如下图：
			- 确认丢失重传 ![[Drawing 2023-08-15 16.49.26.excalidraw]]
			- 报文段100没有重传![[Drawing 2023-08-15 16.55.52.excalidraw]]
			- 第一个报文段确认丢失，但在超时事件发生前主机A收到120的确认报文，主机A认为已经收到了序号为120之前的所有字节，所以主机A不会重传两个报文段中的任何一个![[Drawing 2023-08-15 17.12.30.excalidraw]]
	- 差错恢复机制：TCP类似GBN（回退N步），但是实际中TCP会将接收到的失序的报文段缓存起来。如果某一个确认报文分组丢失，但是其余的报文在超时前到达发送端。TCP将重传至多一个报文段，即丢失的确认报文的数据。如果，n+1的确认报文在报文段n超时之前到达，TCP甚至不会重传分组n。***TCP差错恢复机制可以看成GBN协议和SR协议的混合体**。
	- 流量控制：防止缓存溢出，消除发送方发送数据过快，让接收方缓存溢出的可能性。
		- 通过**接收窗口（receive window）** 的变量来提供流量控制（相当于给发送方一个指示，接收方还有多少可用的缓存空间），TCP是全双工的，所以连接两端都需要维护一个接收窗口。
		- LastByteRead：主机应用进程从缓存读取的数据流的最后一个字节的编号。
		- LastByteRcvd：从网络中到达并且放入主机接收缓存的数据流的最后一个字节的编号。
		- 当满足LastByteRcvd - LastByteRead <=RcvBuffer(接收缓存大小)，不会溢出。
		- rwnd（空闲空间）=RcvBuffer- [ LastByteRcvd - LastByteRead]。rwnd是动态改变的，通过将当前的rwnd值放入报文段的窗口字段中，通过发送方还有多少缓存空间。
		- 有个特殊情况，当接收方的rwnd为0发送给发送方时，那么发送方不会在发送数据，这导致阻塞，所以，当rwnd为0时，发送方继续发送只有一个字节数据的报文段。这个报文段会被接受饭确认。缓存开始清空，在确认报文包含一个非0的rwnd值。
	- 拥塞控制：由于路由器缓存溢出引起的。
		- 情况一：两个发送方和一台具有无穷大缓存的路由器
		- 情况二：两个发送方和一台具有有限缓存的路由器
		- 情况三：4个发送方和具有有限缓存的多台路由器及多跳路由
	- 发送缓存/接收缓存：TCP在发送和接收之间都有一个缓存区域。发送和接收都要经过对应的缓存区域。
	- 最大报文段长度(MSS)：由收发双方每一个报文段能承载最大数据长度（应用层的数据），通常为1460。