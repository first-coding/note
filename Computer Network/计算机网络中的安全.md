- **安全通信特征**：
	1. [[计算机网络中的安全#^c375f4|机密性]]：仅有发送方和希望的接收方能够理解传输报文的内容。窃听者可以截获报文，所以报文要在一定程度上进行加密。
	2. [[计算机网络中的安全#^86eeed|报文完整性]]：希望通信内容在传输过程中未出错，未被改变（恶意篡改或意外改动）
	3. [[计算机网络中的安全#^4f5f85|端点鉴别]]：发送方和接收方都应该能证实通信过程所涉及的另一方。以确保通信的另一方是其声称的身份。
	4. [[计算机网络中的安全#^b5888a|运行安全性]]：几乎所有机构的网络都连上了公共因特网，这些网络会有潜在的危险。安放蠕虫，DoS攻击，获取机密信息。防火墙就是位于机构和公共网络之间的。
- **密码学原则（机密性）**：所有的密码算法都涉及用一种东西替换另一种东西的思想。 ^c375f4
	- #加密技术：
		- **密钥就是由一系列比特组成的字符串。**
		- **在大多数加密算法中，密钥是作为加密算法的输入进行的，相当于f（x）=a+b，a为明文，f(x)为密文，b为密钥。通过输入密钥才能得到f(x),对应的解密的必须知道密钥才能得出a，对称加密算法几乎都是这样**
		- **在非对称加密算法中，密钥大多数并不是作为输入，而是通过算法形成的一对值**
		- **对称和非对称加密技术通过对称加密算法和非对称加密算法进行分类**
		- #对称加密技术：
			- #对称密钥密码体系：
				- 使用相同的密钥进行加密和解密。具有高效性和速度快的特点。适用于大量数据的加密和解密过程。主要挑战是如何安全的共享密钥。
			- #对称加密技术类型： 
				1. 块密码：它将明文划分为固定大小的数据块，并使用相同的密钥对每个数据块进行加密。块密码算法通过对每个数据块应用加密操作（如置换、替换、混淆等），从而将明文转换为密文。常见的块密码算法有DES（Data Encryption Standard）、AES（Advanced Encryption Standard）等，多用于因特网协议的加密，PGP（安全电子邮件），SSL（用于使TCP连接更安全）和IPsec（用于使网络层传输更安全）
					1. 随着分块的大小的变大，导致组合起来的数字十分大，而通信的双方难以维护一张巨大的数据值表也难以根据变化而重新生成对应的表，所以块密码通常使用函数模拟随机排列表。通过函数映射的关系进行加密得到密文。
					2. **密码块链接（密码块的改进）**：如果将报文切割成k比特块的话并独立加密每块，有可能存在着两个或以上的明文块是相同的，所以对应的密文也是相同的。这样窃听者有可能通过相同的密文块潜在的猜出明文。为了解决这个问题引入了随机性，使相同的明文块生成不同的密文块。发送方为第i块生成一个随机的比特数r（i），并计算c（i）=Ks（m（i）XOR r（i）），ks代表具有密钥S的块密码加密算法。c（i）代表第i个密文块，m（i）代表第i个明文块。发送方会将c（i）和r（i）发送出去，r（i）以明文方式发送。即使截获了因为不知道Ks所以也无法知道明文。接收方也是通过计算解码密文得到明文。但是会存在一个问题要传输以前两倍的比特，因为多了一个随机的比特数。为了更好的运用这个随机的比特数，块密码使用一种**密码块链接（Cipher Block Chaining，CBC）**，（需要一个协议提供一种机制，从发送方向接收分发IV），即仅在第一个报文发送的时候发送一个随机值，然后发送方和接收方使用计算机的编码块代替后续的随机数。步骤如下：
					3. 在加密报文（或数据流）之前，发送方生成一个随机的k比特串，称为**初始向量（Initialization Vector，IV）**，表示为C（0），发送方以明文方式将IV发送给接收方。
					4. 对第一个块，发送方计算m（1）XOR C（0），即计算第一块明文与IV的异或（相同为0，不同为1），通过块密码算法运行得到结果得到对应的密文块，c（1）=Ks（m（1）XOR c（0））发送方向接收方发送加密块c（1）。
					5. 对于第i个块，发送方根据c（i）=Ks（m（i）XOR c（i-1））生成第i个密文块。
				2. 流密码：它将数据流（比特或字节序列）与密钥进行逐位或逐字节的异或运算，从而实现加密和解密。流密码算法基于密钥和初始化向量（IV），生成伪随机密钥流，该密钥流与明文进行异或运算，生成密文。常见的流密码算法有RC4（Rivest Cipher 4）、Salsa20、ChaCha20等 
			- #对称加密算法：
				1.  凯撒密码：英语文本，将明文报文中的每个字母用字母表中该字母后k个字母进行替换。可以回绕（z下一个是a）
				2. 单码代替密码（凯撒密码的改进方法）：使用字母表中的另一个字母进行替换，只要确保每一个字母都有唯一的替换字母即可
				3. 多码代替密码（单码代替密码的改进）：使用多个单码代替密码，例如使用多个凯撒密码进行编码，前几个字母用第一个凯撒密码进行编码，后几个字母用第二个凯撒密码编码。 
		**凯撒密码到20实际70年代存在一个问题，就是这个对称密钥要先进行通信才知道，就是双方都要有这个对称的密钥。 所以出现了公开密钥系统。** 
		- #非对称加密技术： 
			- #公开密钥系统：
				1. 使用一对密钥，包括**公钥（KB+）** 和 **私钥（KB-）**。公钥共享（用于加密数据），私钥独有保密（用于解密数据）。具有更高安全性，但速度较慢。常用于密钥交换，数字签名，身份验证等领域。
				2.  如果两者要通信的话。过程如下：
					 1. 发送方先取得公钥，之后用公钥和加密算法，加密并传递出去，即计算KB+（m）。
					 2. 接收方接收到密文后，用私钥和解密算法解密，计算KB-（KB+（m））。
				3. 但是存在两个问题。
					 1. 入侵者知道公钥，可以选择明文攻击，使用全世界已知的标准加密算法和公钥进行破解。这个问题就需要密钥选择算法的时候要保证破解很困难，几乎不可破解的了，即计算量超级大的那种。
					 2. 存在着身份的问题，任何人都可以伪装成别人去发送报文。这需要使用数字签名将发送方和报文绑定来解决。
			- #非对称加密算法：
				 - RSA算法：
					 - 广泛使用模n算术的算术运算。$$(a \bmod n)^{d}\bmod n = a^{d} \bmod n $$这个恒等式和RSA工作原理相关。
					 - 假设 Alice向Bob发送RSA加密的报文，一个报文就是一种比特模式，所有的比特模式能唯一的被一个整数表示。例如 1001十进制表示为9。所以当RSA加密一个报文的时候，等价于加密表示该报文的这个唯一的整数。
					   RSA有两个互相关联的部分：
						   公钥和私钥的选择
						   加密和解密算法
					 - 步骤如下
						 - **接收方（Bob）**：
							 `1.选择两个素数（大于1且只能被1和自身整除的自然数）p和q，p和q越大，破解越困难，加密和解密所需时长越长`
							`2.计算n=pq和z=（p-1）（q-1）`
							`3.选择数e（e<n），且e和z没有（非1的）公因数（称e与z互素）这个字母e用于加密`
							 `4.求一个数d，使ed-1可以被z整除（没有余数）。使用字母d进行解密，即ed mod z=1`
							 `5.公钥KB+是一对数（n，e），私钥KB-是一对数（n，d）`
						- **发送方（Alice）**：
							`1.Alice要给Bob发送一个整数m表示的比特组合，m<n，c = m^e mod n（c为加密后的密文）`
							`2.Bob（接收方） m=c^d mod n` 
					- 因为RSA进行指数级运算相当耗费时间，实际应用中，RSA和对称密钥密码结合使用。Alice选择一个加密的密钥，称为**会话密钥**，表示为Ks，Alice发送这个会话密钥的时候使用Bob的RSA公钥进行加密会话密钥。即计算$$c = (K_s)^{e}\bmod n $$Bob接收到会话密钥就可以解密密文了。
					- RSA算法的安全性依赖于**目前没有已知的算法可以快速进行一个数的因数分解。无法快速分解出素数p和q。**
	-  #破解密文的难易情况分为三种： 
		 1. 唯密文攻击：入侵者只能截获到密文，不了解明文内容。统计分析会有助于对加密的唯密文攻击
		 2. 已知明文攻击：知道部分密文的内容，可以通过已知的去确定字母的匹配关系，这时就会有助于解密所有的密文内容。
		 3. 选择明文攻击：选择一个明文并得到该明文的密文形式去破解较为简单的加密技术，但是对于复杂的加密技术来说，不一定能够攻破加密机制。
- **报文完整性和数字签名（报文完整性）**：（报文在传输过程中没有被篡改，修改，破坏或者加入安全风险） ^86eeed
	- #密码散列函数：散列函数以m作为输入，计算得到一个称为散列的固定长度的字符串H（m）。
		- x!=y  H(x)=H(y)是不可能的。
	- #散列算法：
		- MD5散列算法：用于将任意长度的数据映射为固定长度的密文，输出为128位（16字节）的摘要。
			- #特点：
				1. 输入：MD5算法接受任意长度的输入数据。
				2. 输出：生成固定长度为128位（16字节）的摘要
				3. 不可逆性：MD5算法是单向散列函数，无法逆向还原初始数据。
				4. 相同输入生成相同输出：不论多少遍，相同的输入得出相同的摘要（输出）。
				5. 雪崩效应：即使输入数据有微小的变化，生成的摘要也有巨大的变化。
			- #步骤：
				- ![[屏幕截图 2023-07-09 152749.png]]
				```通过Hello，World！举例：
                1.输入字符串：Hello，World！
	            2.转换为二进制：01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001
	            3.填充数据: 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001 10000000 00000000 ... 00000000 (填充1后面跟随零直到满足512位)
	            4.分组处理: - 第一块: 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001 10000000 ... 00000000 - 其他块: (如果有多个块)
	            5.初始化寄存器: A = a0, B = b0, C = c0, D = d0 
	            6.处理块: - 对第一块进行一系列的位运算、逻辑函数和常量的操作，更新寄存器的值。 
	            7.连接寄存器值: 将最终的寄存器值连接起来，形成128位（16字节）的MD5散列值。 
	            8.MD5散列值: e10adc3949ba59abbe56e057f20f883e
				```
		- SHA-1算法：
			- #步骤
			- ![[Pasted image 20230709155357.png]]
			```
				1.输入字符串: Hello, World!
				2.转换为二进制: 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001 
				3.填充数据: 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001 10000000 ... 00000000 (填充1后面跟随零直到满足512位) 
				4.分组处理: - 第一块: 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001 10000000 ... 00000000 - 其他块: (如果有多个块) 
				5.初始化寄存器: A = a0, B = b0, C = c0, D = d0, E = e0 处理块: - 第一块进行一系列的位运算、逻辑函数和常量的操作，更新寄存器的值。 
				6.连接寄存器值: 将最终的寄存器值连接起来，形成160位（20字节）的SHA-1散列值。 
				7.SHA-1散列值: 2ef7bde608ce5404e97d5f042f95f89f1c232871
			```
		- 相对于来说SHA-1比MD5更安全。
	- #散列函数的应用：
		- 报文鉴别码（用于验证报文保证性）：
			- 一个简单的过程如下：
				1. Alice（发送方）生成报文m并计算散列H（m）
				2. Alice（发送方）将H（m）附加到报文m上，生成拓展报文（m，H（m）），并发给Bob（接收方）
				3. Bob接收到（m，h），然后计算H（m），如果H（m）=h，一切正常
			- 但是存在一个问题：第三者可以生成虚报报文，然后声称自己是Alice，然后依据前面两步发送给Bob（接收方），而Bob认为他就是Alice。通过鉴别密钥来进行识别。Alice和Bob共享密码s。
				1. Alice生成报文m，用s级联m生成m+s，计算散列H（m+s）（称为报文鉴别码（Message Authentication Code，MAC））
				 2. Alice将MAC附加在m上，生成拓展报文（m，H（m+s）），并发送给Bob。
				 3. Bob接受一个拓展报文（m，h），知道s，所以计算H（m+s），相同的话一切正常
				 但是如何分发这个s，在路由选择算法，自治系统向每台路由器分发鉴别密钥。
		- 数字签名（用于验证身份）：
			- 因为通过加密和解密算法进行数据签名的话，开销会很大，所以通过散列函数进行数字签名。步骤如下：
				-  报文m通过散列函数得到H（m），然后计算KB-（H（m）） ，因为H（m）会小一点。所以开销会较小。通过对散列函数进行数字签名。私钥是通过算法得到的。
				- 而接收方会通过公钥KB+进行解密，然后得到相同的报文的话就说明身份是对应的。因为公钥和私钥是一对的（KB+，KB-）。 
			- 公钥认证：证实一个公钥属于某个特定的实体。（差不多就是这个公钥要和某个实体绑定，给用户信任），由认证中心（Certification Authority，CA）完成。
				- 但是并没有强制过程，所以这个CA机构要被人们信任。
- **端点鉴别（一个实体经过网络向另一个实体证明其身份的过程）**： ^4f5f85
	- 直接发
	- 通过通信的周知网络地址发送
	- 用口令
	- 上一步的口令加密
	- 最后就是对口令进行不重复编号，和TCP流量控制一样
- **网络安全的应用**：
	- PGP：应用层上的电子邮件安全协议
	- TCP连接安全SSL：
		1. SSL握手
		2. 密钥导出
		3. 数据传输
		4. 连接关闭
		- 通俗来说就是先进行TCP连接之后，在进行SSL连接，通过接收方的公钥生成SSL会话对称密钥。之后通过密钥对每一个SSL记录进行加密发送操作。
	- 网络层安全（IPsec和虚拟专用网）：
		- 为任意两个网络层实体（主机，路由器）之间IP数据报提供安全。
		- AH协议和ESP协议：鉴别首部和封装安全性载荷，AH协议提供源鉴别和数据完整性服务。ESP协议提供源鉴别和数据完整性和机密性服务。具体见（计算机网络：自顶向下方法第417-420）
	- 无线LAN安全：WEP协议为主机和接入点（基站）提供鉴别和数据的加密
		- IEEE 802.11i四流程：
			1. 发现
			2. 相互鉴别和主密钥（MK）生成
			3. 成对主密钥（PMK）生成
			4. 临时密钥（TK）生成
- **运行安全性（防火墙和入侵检测系统）**： ^b5888a
	- 防火墙：
		1. 传统的分组过滤器
		2. 状态分组过滤器
		3. 应用程序网关
	- 入侵检测系统：
		- IDS系统
			- IDS入侵检测系统
			- IPS入侵防止系统
			- 可以检测多种攻击，网络映射，端口扫描，TCP栈扫描，DoS带宽洪泛攻击，蠕虫和病毒。